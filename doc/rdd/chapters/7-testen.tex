\chapter{Testen}

\section{Test Konzept}
Das Testen soll der kleinsten zur Größten Einheit ablaufen.
Alle Klassen werden gegen Basis Klassen zu Implementiert (Design for Testability).

\subsection{Unit Test}
Nach dem fertig stellen einer Klasse sollte dieses mithilfe eines Unit Tests geprüft werden (simple Funktionen wie z.B setter und getter müssen nicht getestet werden).
Nach dem ändern dieser Klasse ist der Unit Test nochmals durchzuführen (Regressionstest).
Zur Verifikation des Unit Test sind über einen Whitebox-Test folgende Metriken zu beachten:
\begin{itemize} 
	\item \textbf{Code Coverage:} Diese muss bei 100\% liegen, daraus folgt auch eine 100\%Branch coverage.
	\item\textbf{Condition Coverage:} Komplexe Conditions sollten mit einer Kompletten Wertetabelle getestet werden.
\end{itemize}

\subsection{Komponenten Test}
Nach dem Fertigstellen einer Komponente soll diese, mithilfe des nach außen Sichtbaren Interfaces zuerst mit Stubs und Mocks (ohne Hardware) auf ihre Funktionalität geprüft werden.
Ist dieser Test erfolgreich, so wird der Test erneut auf der Hardware durchgeführt ohne Stub und Mock Objekte in der Komponente. 

Nach ändern der Komponente sind die Tests erneut durchzuführen.

\subsection{Integrationstest}
Fast alle Komponenten Kommuniezieren zentral über den Main Controller.
Je nach dem ob eine Komponente Input für den Controller oder vom Controller gestuert wird(Output), sind folgende Test Durchzuführen.
Bei Komponenten mit in und Output mit In- und Output ist beides zu beachten. Zuerst werden diese Test in einer Testumgebung (ohne Hardware) durchgeführt, 
dabb auf dem echten Anlagen.

TODO Calibration Komponente beachten

\subsubsection{Input}
Erhält der Controller die spezifizierten Signale von der Komponente? Liefert die Komponente die richtigen Signale zum Hardware Input?

\subsubsection{Output}
Verhält sich die Komponente entsprechend zum Eingangssignal?

\subsubsection{Test der MainControll}
Die MainControll wird mit Moch/Stub/Fake und Spy Objekten umgeben, die das Interface der Komponenten implementieren.
Zuerst ist sicherzustellen, das alle Basisfunktionen einzeln funktionieren. Dazu gehören:
\begin{itemize} 
	\item Transport der Pucks
	\item Höhenmessung
	\item Sortieren der Pucks
	\item Rampe Voll
	\item Übergabe an die hintere Anlage (nur bei Anlage 1);
	\item E-Stopp
	\item Fehlerbehandlung
	\begin{itemize}
		\item Ampelanlage
		\item Knöpfe
	\end{itemize}
\end{itemize}

\subsection{System Test}
Jedem Requirement wird mindestens ein Test zugewiesen. Dieser Test wird auf der Gesamten Anlage durchgeführt. 
Die Zuordnung von Requirement auf Test erfolgt mithilfe einer Trace Matrix.
Hier wird eingetragen, ob der Test zum Requirement bestanden wurde oder nicht.

\section{Testplan}
TODO Dies ist nur ein Konzept, an Milestones anpassen
\subsection{Unit Tests}
Der Test zu einer Unit soll Parallel zur Unit entwickelt werden. Sobald beide fertig sind, ist der Test durchzuführen.
\subsection{Komponenten Test}
Der Test zu einer Komponente soll vor der Komponente fertig sein, damit mit die Komponente Test-Driven entwickelt werden kann.
Der Test ist nach jedem Entwicklungsschritt der Komponente durchzuführen. An ihm soll sich messen lassen, wie weit die Komponente fortgeschritten ist.
\

\section{Abnahmetest}

Leiten sie die Abnahmebedingungen aus den Kunden-Anforderungen her.
Dokumentieren sie hier, welche Schritte für die Abnahme erforderlich
sind und welches Ergebnis jeweils erwartet wird (Test Cases).

\section{Testprotokolle und Auswertungen}

Hier fügen sie die Test Protokolle bei, auch wenn Fehler bereits
beseitigt worden sind, ist es schön zu wissen, welche Fehler einst
aufgetaucht sind. Eventuelle Anmerkung zur Fehlerbehandlung kann für
weitere Entwicklungen hilfreich sein.
Das letzte Testprotokoll ist das Abnahmeprotokoll, das bei der
abschließenden Vorführung erstellt wird. Es enthält eine Auflistung der
erfolgreich vorgeführten Funktionen des Systems sowie eine Mängelliste
mit Erklärungen der Ursachen der Fehlfunktionen und Vorschlägen zur
Abhilfe.
